  /* Debug: Check 20 Hz timer + timestamp */
  uint32_t tick20_counter = 0;
  shell_printf("20 Hz tick test (5 seconds):\r\n");
  for (int i = 0; i < 100; i++) { /* 100 ticks at 20 Hz = 5 seconds */
      HAL_Delay(50); /* 50 ms delay */
      if (tick20_flag) {
          tick20_counter++;
          tick20_flag = 0; /* Clear the flag */
          shell_printf("  %s\r\n", timestamp(time_us_now()));
      }
  }
  shell_printf("20 Hz ticks counted: %u (expected 100)\r\n", tick20_counter);
  
  /* Debug: Create a FATFS filesystem Object and File Object */
  FATFS fs;
  FIL file;
  FRESULT fres;

  /* Debug: Mount the SD Card */
  if (f_mount(&fs, "", 1) == FR_OK) {
      shell_printf("SD Card mounted successfully\r\n");
  } else {
      shell_printf("Failed to mount SD Card\r\n");
  }

  /* Debug: Dummy WindMaster */
  dummy_WM_init();

  /* Debug: Dummy IMU */
  dummy_IMU_init();

  /* Debug: Start the WindMaster */
  uint64_t wm_start_time;
  dummy_WM_start(&wm_start_time);

  /* Debug: Start the IMU */
  uint64_t imu_start_time;
  dummy_IMU_start(&imu_start_time);
  
  /* Debug: Get current us timestamp */
  //uint64_t start_us = time_us_now();

  if (dummy_WM_is_running()) {
      shell_printf("Dummy WindMaster started\r\n");
  } else {
      shell_printf("Failed to start Dummy WindMaster\r\n");
  }

  /* Debug: Create and write to a test file */
  fres = f_open(&file, "init.txt", FA_OPEN_APPEND | FA_WRITE | FA_CREATE_ALWAYS);
  if (fres == FR_OK) {
      char log_buffer[128];
      const char *ts = timestamp(wm_start_time);
      snprintf(log_buffer, sizeof(log_buffer), "WindMaster Log Start @ %s \r\n", ts);
      UINT bytes_written;
      fres = f_write(&file, log_buffer, strlen(log_buffer), &bytes_written);
      if (fres == FR_OK && bytes_written == strlen(log_buffer)) {
          shell_printf("Created init.txt\r\n", bytes_written);
      } else {
          shell_printf("Failed to write to init.txt\r\n");
      }
  } else {
      shell_printf("Failed to create init.txt\r\n");
  }
  
  /* Debug: Wait for 5 seconds */
  HAL_Delay(5000);

  /* Debug: Stop the IMU */
  uint64_t imu_stop_us;
  dummy_IMU_stop(&imu_stop_us);

  /* Debug: Stop the WindMaster */
  uint64_t stop_us;
  dummy_WM_stop(&stop_us);

  /* Debug: Check if WindMaster is stopped */
  if (!dummy_WM_is_running()) {
      shell_printf("Dummy WindMaster stopped\r\n");
  } else {
      shell_printf("Failed to stop Dummy WindMaster\r\n");
  }

  /* Debug: Check if IMU is stopped */
  if (!dummy_IMU_is_running()) {
      shell_printf("Dummy IMU stopped\r\n");
  } else {
      shell_printf("Failed to stop Dummy IMU\r\n");
  }

  /* Debug: Collect test packets from both WM and IMU DMA buffers */
  LogEntry log_entries[2000];
  int wm_count = 0;
  int imu_count = 0;

  // Process WM buffer
  uint16_t dma_pos_wm = DMA_BUFFER_SIZE - LL_DMA_GetDataLength(DMA2, LL_DMA_CHANNEL_5);
  for (uint16_t i = 0; i <= dma_pos_wm - WM_TEST_PACKET_SIZE && wm_count < 2000; i++) {
      if (dma_buffer_wm[i] == 0xB4 && dma_buffer_wm[i + 1] == 0xB4) {
          uint8_t* packet = &dma_buffer_wm[i];
          log_entries[wm_count].identifier[0] = packet[2];
          log_entries[wm_count].identifier[1] = packet[3];
          log_entries[wm_count].identifier[2] = packet[4];
          log_entries[wm_count].identifier[3] = packet[5];
          log_entries[wm_count].identifier[4] = '\0';
          uint32_t packet_number = (uint32_t)(packet[6] | (packet[7] << 8) | (packet[8] << 16) | (packet[9] << 24));
          log_entries[wm_count].packet_number = packet_number;
          wm_count++;
      }
  }

  // Process IMU buffer
  uint16_t dma_pos_imu = DMA_BUFFER_SIZE - LL_DMA_GetDataLength(DMA2, LL_DMA_CHANNEL_2);
  for (uint16_t i = 0; i <= dma_pos_imu - IMU_TEST_PACKET_SIZE && imu_count < 2000; i++) {
      if (dma_buffer_imu[i] == 0xB4 && dma_buffer_imu[i + 1] == 0xB4) {
          uint8_t* packet = &dma_buffer_imu[i];
          log_entries[wm_count + imu_count].identifier[0] = packet[2];
          log_entries[wm_count + imu_count].identifier[1] = packet[3];
          log_entries[wm_count + imu_count].identifier[2] = packet[4];
          log_entries[wm_count + imu_count].identifier[3] = packet[5];
          log_entries[wm_count + imu_count].identifier[4] = packet[6];
          log_entries[wm_count + imu_count].identifier[5] = '\0';
          uint32_t packet_number = (uint32_t)(packet[7] | (packet[8] << 8) | (packet[9] << 16) | (packet[10] << 24));
          log_entries[wm_count + imu_count].packet_number = packet_number;
          imu_count++;
      }
  }

  // Write to file, interleaving WM and IMU packets
  int max_count = (wm_count > imu_count) ? wm_count : imu_count;
  for (int i = 0; i < max_count; i++) {
      if (i < wm_count) {
          char log_entry[256];
          snprintf(log_entry, sizeof(log_entry), "%s %lu\n", log_entries[i].identifier, log_entries[i].packet_number);
          UINT bytes_written;
          f_write(&file, log_entry, strlen(log_entry), &bytes_written);
      }
      if (i < imu_count) {
          char log_entry[256];
          snprintf(log_entry, sizeof(log_entry), "%s %lu\n", log_entries[wm_count + i].identifier, log_entries[wm_count + i].packet_number);
          UINT bytes_written;
          f_write(&file, log_entry, strlen(log_entry), &bytes_written);
      }
  }

  shell_printf("Total bytes received WM: %u\n", dma_pos_wm);
  shell_printf("Total bytes received IMU: %u\n", dma_pos_imu);
  shell_printf("Total test packets found: %u\n", wm_count + imu_count);

  /* Debug: Write a log footer with the end timestamp */
  char footer[128];
  const char* ts_end = timestamp(stop_us);
  snprintf(footer, sizeof(footer), "\r\nWindMaster Log End @ %s\r\n", ts_end);
  UINT bytes_written;
  f_write(&file, footer, strlen(footer), &bytes_written);

  /* Debug: Close the log file */
  f_close(&file);

  /* Debug: UnMount the SD Card */
  if (f_mount(NULL, "0:", 0) == FR_OK) {
      shell_printf("SD Card unmounted successfully\r\n");
  } else {
      shell_printf("Failed to unmount SD Card\r\n");
  }

  /* Debug: Wait for 3 seconds before continuing */
  HAL_Delay(3000);